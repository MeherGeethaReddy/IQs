Of course! Here's a clean and professional list of 20 Java interview questions with detailed answers, ideal for someone with 5–7 years of experience. This covers Java fundamentals, OOP, concurrency, Java 8 features, and a bit of Spring thrown in.


---

1. What’s the difference between == and .equals() in Java?

Answer:

== checks if two references point to the exact same object in memory.

.equals() checks if the two objects are logically “equal”, based on how it’s overridden.


For example:

String a = new String("hello");
String b = new String("hello");

System.out.println(a == b);      // false (different objects)
System.out.println(a.equals(b)); // true (same content)


---

2. What is a HashMap and how does it work internally?

Answer: HashMap stores key-value pairs and uses hashing for fast access.

Internally:

It computes the hash code of the key, then uses it to find a bucket (an index in an array).

If two keys have the same hash, Java handles this using LinkedList or TreeNode (in case of collisions).


Since Java 8, when a bucket contains more than 8 entries, it turns into a balanced tree (Red-Black Tree) for faster lookups.


---

3. What is the difference between ArrayList and LinkedList?

Feature	ArrayList	LinkedList

Structure	Dynamic array	Doubly-linked list
Lookup	Fast (O(1) via index)	Slow (O(n))
Insert/Delete	Slow in middle (shifting)	Fast in middle (just link/unlink nodes)
Memory	Less overhead	More overhead (extra pointers)



---

4. What is the difference between String, StringBuilder, and StringBuffer?

String is immutable.

StringBuilder is mutable and not thread-safe.

StringBuffer is mutable and thread-safe.


Use StringBuilder when you don’t need synchronization—faster than StringBuffer.


---

5. What are functional interfaces?

Answer: An interface with exactly one abstract method. Example: Runnable, Callable, Comparator.

Java 8 introduced @FunctionalInterface to mark these clearly.

@FunctionalInterface
interface MyFunction {
    int apply(int a, int b);
}

Can be used with lambdas:

MyFunction add = (a, b) -> a + b;


---

6. Explain Lambda Expressions.

Answer: Lambdas are a way to pass behavior (functions) as data.

List<String> list = Arrays.asList("a", "b", "c");
list.forEach(s -> System.out.println(s));

They simplify code, especially with Streams and functional programming.


---

7. What is the Stream API?

Answer: Introduced in Java 8 to process collections in a functional style.

List<String> names = Arrays.asList("Sam", "John", "Sara");
List<String> result = names.stream()
    .filter(name -> name.startsWith("S"))
    .collect(Collectors.toList());

Key methods: map, filter, reduce, collect.


---

8. What’s the difference between final, finally, and finalize()?

final: Used to declare constants or prevent method/variable inheritance.

finally: A block in exception handling that always executes.

finalize(): A method called by the GC before reclaiming memory (deprecated now).



---

9. Explain method overloading and overriding.

Overloading: Same method name, different parameters (compile-time polymorphism).

Overriding: Subclass changes a superclass method (run-time polymorphism).



---

10. What’s the difference between abstract class and interface?

Feature	Abstract Class	Interface

Methods	Can have concrete methods	All methods are abstract (pre Java 8)
Inheritance	One only	Multiple allowed
Constructor	Can have	Cannot have


From Java 8, interfaces can have default and static methods too.


---

11. What are default methods in interfaces?

Java 8 introduced them to allow adding new methods to interfaces without breaking existing implementations.

interface MyInterface {
    default void log() {
        System.out.println("Default log");
    }
}


---

12. What’s the difference between Checked and Unchecked exceptions?

Checked: Checked at compile time (IOException, SQLException).

Unchecked: Run-time exceptions (NullPointerException, ArrayIndexOutOfBoundsException).



---

13. How does Java achieve platform independence?

Because of the Java Virtual Machine (JVM). Java code is compiled to bytecode (.class files), which runs on any machine that has the JVM installed.


---

14. What are static and instance blocks?

Static block: Runs once when the class is loaded.

Instance block: Runs every time an object is created.


static {
    System.out.println("Static block");
}
{
    System.out.println("Instance block");
}


---

15. Explain the transient keyword.

Fields marked as transient are skipped during serialization.

transient String password;

Useful for security-sensitive or temporary data.


---

16. What is garbage collection in Java?

Automatic memory management. Java’s GC removes unreferenced objects from memory.

You can suggest GC using:

System.gc();

But JVM may or may not honor the request.


---

17. What is the difference between synchronized and volatile?

synchronized: Ensures atomicity and visibility using locks.

volatile: Only guarantees visibility, not atomicity.


volatile boolean flag = true;

Use volatile for simple flags, and synchronized when multiple threads must coordinate operations.


---

18. What is the purpose of the Optional class in Java 8?

To avoid NullPointerException. Wraps a value that may or may not be present.

Optional<String> name = Optional.ofNullable(getName());
name.ifPresent(System.out::println);


---

19. What are the types of class loaders in Java?

1. Bootstrap ClassLoader – Loads core Java classes (rt.jar)


2. Extension ClassLoader – Loads ext classes (Java extensions)


3. System/Application ClassLoader – Loads from the classpath



You can also write custom class loaders for dynamic loading.


---

20. What is dependency injection in Spring?

A design pattern where the object dependencies are passed (injected) by the framework instead of the class creating them.

Types:

Constructor Injection

Setter Injection

Field Injection (not recommended)


@Component
public class UserService {
    private final UserRepo repo;

    @Autowired
    public UserService(UserRepo repo) {
        this.repo = repo;
    }
}

Perfect! Continuing from #21 onward, here’s questions 21 to 40, all brand new and not repeated from the previous two sets. These cover advanced Java concepts, multi-threading, JVM internals, design patterns, generics, annotations, and more—ideal for mid-senior interviews:


---

21. What is ThreadLocal and where is it used?

Answer:
ThreadLocal provides thread-confined variables. Each thread accessing a ThreadLocal variable has its own independently initialized copy.

Use case: to avoid sharing variables between threads (e.g., database sessions, user context).

ThreadLocal<Integer> threadLocal = ThreadLocal.withInitial(() -> 1);


---

22. What are enums in Java and why are they useful?

Answer:
Enums define a fixed set of constants in a type-safe way.

enum Status {
    SUCCESS, FAILURE, PENDING
}

They can have fields, constructors, and methods—making them powerful and flexible.


---

23. What is the diamond operator (<>) in generics?

Answer:
Introduced in Java 7 to reduce boilerplate when using generics. It allows type inference.

List<String> list = new ArrayList<>(); // inferred as ArrayList<String>


---

24. What are bounded type parameters in generics?

Answer:
They restrict the types that can be used as type parameters.

<T extends Number> void print(T value) {
    System.out.println(value.doubleValue());
}

This means T can be Integer, Double, etc., but not String.


---

25. What is type erasure in Java generics?

Answer:
Java generics use type erasure to maintain backward compatibility. During compilation, the generic types are replaced with their bounds or Object.

This means:

No runtime info about generic types.

You can't use instanceof List<String> (will throw an error).



---

26. What is the difference between fail-fast and fail-safe iterators?

Feature	Fail-Fast	Fail-Safe

Behavior	Throws ConcurrentModificationException	Works on a clone, no exception
Examples	ArrayList, HashMap iterator	CopyOnWriteArrayList, ConcurrentHashMap



---

27. What is a marker interface?

Answer:
An interface with no methods, used to provide metadata to the JVM or frameworks.

Examples:

Serializable

Cloneable

Remote


They are detected using instanceof.


---

28. What are annotations in Java?

Answer:
Metadata applied to code elements—classes, methods, fields, etc. They can affect:

Compilation

Runtime behavior (via reflection)

Tooling


Examples:

@Override

@Deprecated

Custom annotations like @MyCustomAnnotation



---

29. How do you create a custom annotation?

Answer:

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface LogExecutionTime {}

Use @interface, and specify retention policy and target type.


---

30. What is reflection in Java?

Answer:
A powerful API (java.lang.reflect) that allows inspecting or modifying classes, fields, methods at runtime.

Use cases: frameworks, serialization tools, dependency injection engines.

Drawback: slower and breaks encapsulation.


---

31. What is the difference between shallow copy and deep copy?

Shallow Copy: Duplicates object structure but not nested objects. Both original and copy share nested references.

Deep Copy: Recursively copies all nested objects as well.


You can use:

clone() (shallow by default)

Custom copy constructors

Serialization (for deep copy)



---

32. What is the purpose of transient and static in serialization?

transient: Excludes a field from serialization.

static: Belongs to the class, not the instance—so it's never serialized.



---

33. What are soft, weak, and phantom references in Java?

They’re part of java.lang.ref.*, used in memory-sensitive apps:

SoftReference: Cleared when memory is low.

WeakReference: Cleared on next GC cycle.

PhantomReference: Used for post-mortem cleanup, enqueued after GC.



---

34. What is the difference between stack and heap memory?

Stack: Stores method calls and local variables. Fast, auto-managed, LIFO.

Heap: Stores objects and class instances. Managed by GC.



---

35. What is the ClassLoader in Java?

Answer:
It's responsible for loading .class files into the JVM. Types:

1. Bootstrap ClassLoader


2. Extension ClassLoader


3. System/Application ClassLoader



You can also create custom class loaders (used in frameworks, plugins).


---

36. What is the volatile keyword and when would you not use it?

Answer:
Ensures visibility, but not atomicity. Don't use it for compound actions (e.g., count++)—prefer AtomicInteger or synchronized blocks in such cases.


---

37. What is double-checked locking?

A pattern to ensure that a singleton is created only once, with minimal synchronization overhead.

public class Singleton {
    private static volatile Singleton instance;
    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}


---

38. What is the Builder Pattern?

Used to construct complex objects step-by-step, especially when there are many optional fields.

Person p = new Person.Builder()
                  .name("Alice")
                  .age(30)
                  .build();

Clean, readable, avoids constructor telescoping.


---

39. What is the ForkJoinPool and where is it used?

Introduced in Java 7, ForkJoinPool uses divide-and-conquer strategy for parallelism.

ForkJoinPool pool = new ForkJoinPool();
pool.invoke(new RecursiveTaskExample());

Efficient for large recursive tasks like sorting, searching.


---

40. What is backpressure and how is it handled in Java?

Answer:
Backpressure occurs when a producer generates data faster than the consumer can process.

Handled via:

Blocking queues (LinkedBlockingQueue)

Reactive Streams (Flow.Publisher, Subscriber)

Rate limiters

You got it! Here's a new set of Java interview questions #41 to #60, no repeats, designed to deepen your understanding across various areas: collections, exceptions, performance tuning, Spring basics, multithreading, and more.


---

41. What is the difference between ArrayList and Vector?

Answer:

Both use a dynamic array internally.

ArrayList is not synchronized, so it's faster for single-threaded use.

Vector is synchronized, but considered outdated.


Prefer ArrayList unless you explicitly need thread safety—then go for CopyOnWriteArrayList or concurrent collections.


---

42. What is a ConcurrentHashMap and how is it different from HashMap?

Answer:

ConcurrentHashMap allows concurrent reads and writes without locking the entire map.

Internally it uses bucket-level locking (segment locking in older versions, synchronized blocks in newer ones).

HashMap is not thread-safe.



---

43. What causes ConcurrentModificationException and how do you prevent it?

Answer: It occurs when a collection is modified while iterating over it using iterators.

Solutions:

Use Iterator.remove() instead of list.remove().

Use CopyOnWriteArrayList or concurrent collections.

Or use an explicit index loop.



---

44. What is the difference between throw and throws?

throw: Used to actually throw an exception.

throw new IllegalArgumentException("Invalid input");

throws: Declares what exceptions a method might throw.

public void readFile() throws IOException {}



---

45. Can you override a private or static method in Java?

Answer:

private methods are not inherited, so they cannot be overridden.

static methods can be hidden, not overridden.



---

46. What is the difference between ==, .equals(), and compareTo() for comparing objects?

==: Checks reference equality.

.equals(): Checks logical equality.

compareTo(): Used for ordering; returns negative, zero, or positive based on order.


str1.equals(str2);
str1.compareTo(str2); // for sorting


---

47. What is autoboxing and unboxing?

Answer: Java automatically converts:

primitive → wrapper (autoboxing)

wrapper → primitive (unboxing)


Integer i = 5;   // autoboxing
int j = i;       // unboxing

Be cautious in collections—autoboxing can lead to performance issues in large-scale systems.


---

48. What is a memory leak in Java?

Answer: Occurs when objects are no longer used but still referenced—preventing GC from collecting them.

Common causes:

Static references

Listeners not unregistered

Poor cache implementations



---

49. What is the use of final keyword for variables, methods, and classes?

Variable: Can’t be reassigned.

Method: Can’t be overridden.

Class: Can’t be extended.


final class Vehicle {}


---

50. What are the access modifiers in Java?

Modifier	Same Class	Same Package	Subclass	Other Packages

private	✅	❌	❌	❌
default	✅	✅	❌	❌
protected	✅	✅	✅	❌
public	✅	✅	✅	✅



---

51. What are the different types of exceptions in Java?

Checked (compile-time): Must be declared or handled. Example: IOException.

Unchecked (runtime): NullPointerException, IllegalArgumentException.

Error: Serious problems like OutOfMemoryError, usually not caught.



---

52. What’s the difference between == and compareTo() for String comparison?

==: Compares references.

compareTo(): Lexicographical ordering.

"apple".compareTo("banana"); // negative


Use compareTo() for sorting and ordering.


---

53. What are daemon threads in Java?

Answer: Background threads that do not prevent the JVM from exiting.

thread.setDaemon(true);

Common use: Garbage collector, schedulers.


---

54. What is finalize() and why is it deprecated?

Answer: It was a method called by the garbage collector before reclaiming an object.

Issues:

Unpredictable

Performance cost

Deprecated in Java 9+


Use AutoCloseable or try-with-resources instead.


---

55. How does the synchronized keyword work?

It locks either a method or block so only one thread can execute at a time.


synchronized(this) {
  // thread-safe code
}

Methods can also be declared synchronized.


---

56. What is the transient keyword used for?

Answer: Used in serialization to skip fields.

transient String password;

It won’t be saved to disk or network.


---

57. What is the difference between peek(), map(), and forEach() in Streams?

map(): Transforms the stream.

peek(): Debugging or inspecting without consuming.

forEach(): Terminal operation to consume values.


stream.peek(System.out::println)
      .map(String::toUpperCase)
      .forEach(System.out::println);


---

58. What is method reference and how is it different from lambda?

Answer: A cleaner alternative to lambda when calling an existing method.

list.forEach(System.out::println); // instead of s -> System.out.println(s)

Types:

Static method

Instance method

Constructor (ClassName::new)



---

59. What is a Predicate in Java 8?

Answer: A functional interface that takes one argument and returns boolean.

Predicate<String> startsWithA = s -> s.startsWith("A");

Used in filters and validations.


---

60. What is Optional and how do you avoid nulls with it?

Answer: Optional is a container for a potentially null value.

Optional<String> name = Optional.ofNullable(getName());
name.ifPresent(System.out::println);

Methods:

isPresent()

orElse()

map()

flatMap()

Great! Here's a brand-new batch of Java interview questions #60 to #80 (no repeats from the previous sets). This set dives deeper into real-world problems, Spring Boot, testing, Java features from 9 to 17, performance, and design principles.


---

60. What is the difference between Spring Bean scopes: Singleton vs Prototype?

Answer:

Singleton: Only one instance per Spring container (default).

Prototype: A new bean instance is created every time it’s requested.


@Component
@Scope("prototype")
public class MyBean {}


---

61. What is a memory leak in Java and how do you detect it?

Answer: A memory leak occurs when objects are no longer needed but are still referenced.

Detection Tools:

VisualVM

Eclipse MAT

Java Flight Recorder

Heap dumps analysis



---

62. How does try-with-resources work in Java?

Answer: Introduced in Java 7, it automatically closes resources that implement AutoCloseable.

try (BufferedReader reader = new BufferedReader(new FileReader("file.txt"))) {
    // use reader
}


---

63. What is @ComponentScan and how does it work in Spring?

Answer: It tells Spring where to scan for annotated classes (like @Component, @Service, etc.).

@ComponentScan(basePackages = "com.example.myapp")

Spring uses reflection to discover beans.


---

64. What is the difference between @Controller, @RestController, and @ResponseBody?

@Controller: For web MVC, returns views.

@RestController: Combines @Controller + @ResponseBody.

@ResponseBody: Sends the return value directly in the HTTP response.



---

65. What is @Transactional and how does it work?

Answer: It manages transaction boundaries. If an exception occurs, it rolls back changes.

@Transactional
public void updateUser(User user) {
    // All DB operations here are atomic
}

Supports nested transactions, rollback rules, and propagation.


---

66. What is method reference and how is it different from lambda?

Lambda: (x) -> x.toUpperCase()

Method reference: String::toUpperCase


Cleaner when you're simply calling a method.


---

67. How do you paginate large data sets in Spring Data JPA?

Answer: Use Pageable and Page<T>.

Page<User> users = userRepository.findAll(PageRequest.of(0, 10));

Returns metadata: total pages, total elements, current page, etc.


---

68. What is the difference between eager and lazy loading in Hibernate?

Eager: Loads related entities immediately.

Lazy: Loads only when accessed.


Lazy is default for @OneToMany, and eager for @ManyToOne.


---

69. What are the differences between Mono and Flux in Spring WebFlux?

Mono: 0 or 1 item (single result).

Flux: 0 to N items (stream of results).


WebFlux uses reactive programming for non-blocking I/O.


---

70. What are sealed classes in Java 17?

Answer: They restrict which classes can extend them.

public sealed class Animal permits Dog, Cat {}

Enhances control and security over class hierarchies.


---

71. What is virtual thread (Project Loom)?

Answer: A lightweight thread introduced in Java 21 to scale concurrency massively.

It’s managed by the JVM rather than OS, enabling millions of threads.


---

72. What is the Builder Pattern and when do you use it?

Answer: Used when a class has many optional parameters or when you want to avoid telescoping constructors.

User user = new UserBuilder().name("John").age(30).build();


---

73. How does Spring Boot autoconfiguration work?

Answer:

Spring scans classpath and registers default configurations.

Controlled using @EnableAutoConfiguration and spring.factories.


It works with condition-based classes like @ConditionalOnClass.


---

74. What is the difference between @Bean, @Component, and @Configuration?

Annotation	Purpose

@Component	Marks a class as a Spring Bean
@Bean	Declares a method that returns a bean manually
@Configuration	Declares a class that defines beans



---

75. What is method chaining and how is it used in fluent APIs?

Answer: Calling multiple methods in a single expression.

builder.setName("John").setAge(25).build();

Useful in DSLs and builders.


---

76. How do you handle global exceptions in Spring Boot?

Answer: Use @ControllerAdvice + @ExceptionHandler.

@ControllerAdvice
public class GlobalExceptionHandler {
    @ExceptionHandler(Exception.class)
    public ResponseEntity<String> handle(Exception e) {
        return ResponseEntity.status(500).body("Error occurred");
    }
}


---

77. What is the difference between a static class and a singleton?

Static class: Cannot be instantiated. All methods are static.

Singleton: One instance per JVM. Allows interface implementation, state retention.



---

78. What are some common memory tuning JVM options?

-Xms512m     // Initial heap size  
-Xmx2g       // Max heap size  
-XX:+UseG1GC // Use G1 garbage collector  
-XX:+HeapDumpOnOutOfMemoryError

Used to manage memory for high-performance systems.


---

79. What is the difference between RuntimeException and Error?

RuntimeException: Application-level bugs (NullPointerException, IllegalArgumentException).

Error: JVM-level problems (OutOfMemoryError, StackOverflowError)—not meant to be caught.



---

80. What is tight coupling vs loose coupling?

Tight coupling: Classes depend heavily on each other—less flexible.

Loose coupling: Classes interact via interfaces or injection—more maintainable.


Spring’s DI promotes loose coupling by managing dependencies externally.

Absolutely! Here’s your next solid batch — Java interview questions #81 to #100, fully unique, no repeats, and perfect for mid-to-senior interviews. This set continues with core Java, adds Spring and Microservices touches, and includes testing, immutability, stream tricks, and Java 11–17 features.


---

81. What’s the difference between peek() and forEach() in Java Streams?

Answer:

peek() is an intermediate operation used for debugging or inspecting without consuming.

forEach() is a terminal operation—it ends the stream.


list.stream().peek(System.out::println).collect(Collectors.toList());


---

82. How do you reverse a List in Java?

Answer: Use Collections.reverse() for in-place reversal.

Collections.reverse(myList);

Or use Streams:

List<String> reversed = list.stream()
    .collect(Collectors.collectingAndThen(Collectors.toList(), l -> {
        Collections.reverse(l);
        return l;
    }));


---

83. What is immutability and how do you create an immutable class in Java?

Answer: An immutable class:

Is final

Has final fields

No setters

Defensive copies on access


public final class User {
    private final String name;
    public User(String name) { this.name = name; }
    public String getName() { return name; }
}


---

84. What is method overriding with covariant return types?

Answer: In Java, when overriding a method, the return type can be a subclass of the original return type.

class A {
    Number getValue() { return 1; }
}
class B extends A {
    Integer getValue() { return 2; } // Covariant return
}


---

85. What is the difference between Exception and Error?

Exception: Recoverable, application-level issues.

Error: Serious issues (like OutOfMemoryError, StackOverflowError) that shouldn't be caught.



---

86. How does Java handle parameter passing — by value or by reference?

Answer: Java is always pass-by-value. For objects, the reference is passed by value (so changes to object state persist, but reassignments don’t reflect outside).


---

87. What is a Predicate vs Function in Java 8?

Interface	Input	Output	Purpose

Predicate	T	boolean	Conditional checks
Function	T	R	Transformations



---

88. What is the default scope of a Spring Bean?

Answer: Singleton. One shared instance per Spring context.


---

89. What is the difference between isPresent() and ifPresent() in Optional?

isPresent(): Checks if value exists.

ifPresent(): Performs an action if present.


optional.ifPresent(val -> System.out.println(val));


---

90. How do you write a custom exception in Java?

public class MyException extends Exception {
    public MyException(String message) {
        super(message);
    }
}

Can also extend RuntimeException for unchecked exceptions.


---

91. What is the difference between Mono and CompletableFuture?

Mono (from Reactor): Reactive type, integrates with event loops, supports backpressure.

CompletableFuture: Java’s Future with callbacks, still blocking by default.


Use Mono in reactive pipelines, CompletableFuture in async Java logic.


---

92. What is the diamond problem in multiple inheritance and how does Java resolve it?

Java doesn’t allow multiple inheritance of classes. With interfaces, if there's ambiguity in default methods, Java forces the class to override the method.


---

93. What is a default method conflict in Java interfaces?

If two interfaces define the same default method, the implementing class must override it to resolve ambiguity.

interface A { default void hello() {} }
interface B { default void hello() {} }

class C implements A, B {
    public void hello() { A.super.hello(); }
}


---

94. What’s the difference between flatMap() in Optional and Stream?

Optional.flatMap(): Takes a function returning Optional.

Stream.flatMap(): Takes a function returning Stream and flattens nested structures.



---

95. How do you test exceptions using JUnit 5?

Assertions.assertThrows(IllegalArgumentException.class, () -> {
    someMethod(null);
});


---

96. How do you mock dependencies using Mockito?

@Mock UserRepository repo;
@InjectMocks UserService service;

when(repo.findById(1)).thenReturn(Optional.of(user));

Mockito injects mocks into the class under test.


---

97. How do you stop infinite recursion in serialization (e.g., bi-directional relationships)?

Use annotations like:

@JsonManagedReference

@JsonBackReference
(From Jackson for JSON serialization)



---

98. What is the purpose of @RequestParam vs @PathVariable in Spring?

@RequestParam: Extracts values from query parameters (?id=5)

@PathVariable: Extracts values from URI segments (/user/5)



---

99. What is the purpose of Optional.orElse() vs Optional.orElseGet()?

orElse(): Always evaluates the argument.

orElseGet(): Lazily evaluates only if empty.


optional.orElse(createNewUser());      // always called
optional.orElseGet(() -> createNewUser()); // called only if needed


---

100. What are records in Java and when should you use them?

Answer:
Java records (Java 14+) are immutable data carriers.

public record User(String name, int age) {}

They auto-generate constructor, getters, equals(), hashCode(), toString().


